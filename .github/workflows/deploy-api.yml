# Deploy FastAPI (LifeBook API) to Azure Container Apps.
# Trigger: only via Deploy All (workflow_call) or manual workflow_dispatch. No push trigger to avoid duplicate runs.
# Builds Docker image from services/api, pushes to ACR, updates Container App.
# Uses --cache-from previous image in ACR so base + pip layers are reused; only changed layers are pushed.
# All Azure resources must be in West US 3 (westus3).
#
# GitHub secrets (use ONE of these options):
#   Option A: AZURE_CREDENTIALS = full JSON from:
#     az ad sp create-for-rbac --name "LifeBook-GitHub" --role contributor \
#       --scopes /subscriptions/<SUB_ID>/resourceGroups/rg-lifebook-v1 --sdk-auth
#     Workflow accepts both formats: clientId/clientSecret/subscriptionId/tenantId OR appId/password/tenant (subscriptionId required).
#   Option B: AZURE_CLIENT_ID, AZURE_TENANT_ID, AZURE_SUBSCRIPTION_ID, AZURE_CLIENT_SECRET
#
# Optional (synced to Container App on deploy; else set in Azure Portal):
#   DATABASE_URL, AZURE_STORAGE_ACCOUNT, AZURE_STORAGE_ACCOUNT_KEY, OPENAI_API_KEY, CORS_ALLOW_ORIGINS
#   AZURE_STORAGE_CONTAINER_PHOTOS, AZURE_STORAGE_CONTAINER_AUDIO
#   PICOVOICE_ACCESS_KEY, VOICE_ID_BACKEND (Voice ID, default Eagle), or AZURE_SPEECH_KEY, AZURE_SPEECH_REGION, AZURE_SPEECH_ENDPOINT (Voice ID when backend=azure)
#
# GitHub variables (or set in workflow):
#   AZURE_RESOURCE_GROUP  - e.g. rg-lifebook-v1
#   AZURE_ACR_NAME       - e.g. lifebookv1acr (no .azurecr.io)
#   AZURE_CONTAINER_APP  - e.g. aca-lifebook-api-v1
#   AZURE_LOCATION       - (optional) default westus3 (West US 3)

name: Deploy API (Azure Container Apps)

on:
  workflow_dispatch:
  workflow_call:

env:
  RESOURCE_GROUP: ${{ vars.AZURE_RESOURCE_GROUP || 'rg-lifebook-v1' }}
  ACR_NAME: ${{ vars.AZURE_ACR_NAME || 'lifebookv1acr' }}
  CONTAINER_APP: ${{ vars.AZURE_CONTAINER_APP || 'aca-lifebook-api-v1' }}
  CA_ENV: ${{ vars.AZURE_CONTAINER_APPS_ENV || 'acae-lifebook-v1' }}
  AZURE_LOCATION: ${{ vars.AZURE_LOCATION || 'westus3' }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          # Pin to the commit that triggered this deploy (required when called via workflow_call:
          # otherwise checkout may use branch tip instead of trigger commit, so API can deploy stale code).
          ref: ${{ github.sha }}

      - name: Prepare Azure credentials
        id: azcreds
        run: |
          set -e
          echo "==> Preparing Azure credentials (AZURE_CREDENTIALS or AZURE_CLIENT_ID/SECRET/TENANT_ID)..."
          DELIM="CREDS_$(openssl rand -hex 8)_END"
          if [ -n "${AZURE_CREDENTIALS:-}" ]; then
            echo "==> Using AZURE_CREDENTIALS JSON..."
            node -e "
              const raw = process.env.AZURE_CREDENTIALS;
              const o = JSON.parse(raw);
              const out = {
                clientId: o.clientId || o.appId || '',
                clientSecret: o.clientSecret || o.password || '',
                subscriptionId: o.subscriptionId || '',
                tenantId: o.tenantId || o.tenant || ''
              };
              if (!out.clientId || !out.tenantId || !out.clientSecret) {
                throw new Error('AZURE_CREDENTIALS must have clientId (or appId), tenantId (or tenant), clientSecret (or password). Add subscriptionId if missing.');
              }
              require('fs').writeFileSync('creds.json', JSON.stringify(out));
            "
          else
            echo "==> Using AZURE_CLIENT_ID / AZURE_CLIENT_SECRET / AZURE_TENANT_ID..."
            node -e "
              const c = process.env.CID || '';
              const s = process.env.SECRET || '';
              const sub = process.env.SID || '';
              const t = process.env.TID || '';
              if (!c || !s || !t) throw new Error('Set AZURE_CLIENT_ID, AZURE_CLIENT_SECRET, AZURE_TENANT_ID (and AZURE_SUBSCRIPTION_ID). Or use AZURE_CREDENTIALS JSON.');
              require('fs').writeFileSync('creds.json', JSON.stringify({ clientId: c, clientSecret: s, subscriptionId: sub, tenantId: t }));
            "
          fi
          echo "creds<<${DELIM}" >> $GITHUB_OUTPUT
          cat creds.json >> $GITHUB_OUTPUT
          echo "" >> $GITHUB_OUTPUT
          echo "${DELIM}" >> $GITHUB_OUTPUT
          echo "==> Azure credentials prepared successfully."
        env:
          AZURE_CREDENTIALS: ${{ secrets.AZURE_CREDENTIALS }}
          CID: ${{ secrets.AZURE_CLIENT_ID }}
          SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
          SID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          TID: ${{ secrets.AZURE_TENANT_ID }}

      - name: Azure Login
        uses: azure/login@v2
        with:
          creds: ${{ steps.azcreds.outputs.creds }}

      - name: Ensure API infrastructure exists
        run: |
          set -e
          echo "==> Ensuring API infrastructure (RG, ACR, Container Apps env, Container App)..."
          RG="${{ env.RESOURCE_GROUP }}"
          ACR="${{ env.ACR_NAME }}"
          CA_ENV="${{ env.CA_ENV }}"
          APP="${{ env.CONTAINER_APP }}"
          LOC="${{ env.AZURE_LOCATION }}"
          echo "==> Checking resource group $RG..."
          if ! az group show -n "$RG" &>/dev/null; then
            echo "==> Creating resource group $RG in $LOC"
            az group create -n "$RG" -l "$LOC"
          fi
          echo "==> Checking ACR $ACR..."
          if ! az acr show -n "$ACR" &>/dev/null; then
            echo "==> Creating ACR $ACR"
            az acr create -g "$RG" -n "$ACR" --sku Basic -l "$LOC"
          fi
          echo "==> Checking Container Apps environment $CA_ENV..."
          if ! az containerapp env show -g "$RG" -n "$CA_ENV" &>/dev/null; then
            echo "==> Creating Container Apps environment $CA_ENV"
            if ! az containerapp env create -g "$RG" -n "$CA_ENV" -l "$LOC"; then
              echo "Create returned error (may be 'operation in progress'). Waiting for environment to become ready (poll up to 10 min)..."
              for i in $(seq 1 20); do
                sleep 30
                if az containerapp env show -g "$RG" -n "$CA_ENV" &>/dev/null; then
                  echo "Environment is ready"
                  break
                fi
                echo "  poll $i/20: not ready yet"
              done
            fi
            az containerapp env show -g "$RG" -n "$CA_ENV" || (echo "==> ERROR: Environment not ready after wait" && exit 1)
          fi
          echo "==> Checking Container App $APP..."
          if ! az containerapp show -g "$RG" -n "$APP" &>/dev/null; then
            echo "==> Creating Container App $APP"
            az containerapp create -g "$RG" -n "$APP" --environment "$CA_ENV" \
              --image mcr.microsoft.com/azuredocs/containerapps-helloworld:latest \
              --ingress external --target-port 80
            echo "Add DATABASE_URL, AZURE_STORAGE_*, OPENAI_API_KEY, CORS_ALLOW_ORIGINS in Azure Portal → Container App → Configuration"
          else
            echo "==> Container App $APP already exists."
          fi
          echo "==> API infrastructure check complete."

      - name: Verify API source (delete route)
        run: |
          echo "==> Building from commit ${{ github.sha }}"
          if ! grep -q '"/stories/shared/delete"' services/api/app/routers/voice.py; then
            echo "==> ERROR: services/api/app/routers/voice.py does not contain the delete route. Check commit and workflow ref."
            exit 1
          fi
          echo "==> Delete route present in source."

      - name: Login to ACR
        run: |
          echo "==> Logging in to ACR ${{ env.ACR_NAME }}..."
          az acr login --name ${{ env.ACR_NAME }}
          echo "==> ACR login successful."

      - name: Build Docker image
        id: build
        run: |
          set -e
          echo "==> Building API Docker image (services/api)..."
          ACR="${{ env.ACR_NAME }}"
          REGISTRY="${ACR}.azurecr.io"
          IMAGE="${REGISTRY}/lifebook-api:${{ github.sha }}"
          IMAGE_LATEST="${REGISTRY}/lifebook-api:latest"
          echo "IMAGE=$IMAGE" >> $GITHUB_ENV
          # Use --no-cache to avoid stale COPY app layers (production had 404 on delete route
          # despite correct commit; cached layers may have served old code).
          docker build --no-cache --build-arg BUILD_SHA=${{ github.sha }} -t "$IMAGE" ./services/api
          echo "==> Docker build finished. Image: $IMAGE"

      - name: Push image to ACR
        run: |
          set -e
          IMAGE="${{ env.IMAGE }}"
          IMAGE_LATEST="${IMAGE%:*}:latest"
          echo "==> Pushing $IMAGE to ACR..."
          docker push "$IMAGE"
          echo "==> Pushing $IMAGE_LATEST..."
          docker tag "$IMAGE" "$IMAGE_LATEST"
          docker push "$IMAGE_LATEST"
          echo "==> Push complete."
        # Service principal must have AcrPush on the ACR (or Contributor on the ACR resource)

      - name: Ensure Container App can pull from ACR
        run: |
          set -e
          echo "==> Ensuring Container App can pull from ACR..."
          RG="${{ env.RESOURCE_GROUP }}"
          ACR="${{ env.ACR_NAME }}"
          APP="${{ env.CONTAINER_APP }}"
          SERVER="${ACR}.azurecr.io"
          EXISTING=$(az containerapp show -g "$RG" -n "$APP" --query "properties.configuration.registries[?server=='$SERVER'].server" -o tsv 2>/dev/null || true)
          if [ "$EXISTING" = "$SERVER" ]; then
            echo "==> Registry $SERVER already configured, skipping."
            exit 0
          fi
          echo "==> Enabling ACR admin and setting registry for $APP..."
          az acr update -g "$RG" -n "$ACR" --admin-enabled true --output none
          ACR_PASS=$(az acr credential show -g "$RG" -n "$ACR" --query "passwords[0].value" -o tsv)
          for attempt in 1 2 3 4 5 6 7 8 9 10; do
            if az containerapp registry set -g "$RG" -n "$APP" --server "$SERVER" --username "$ACR" --password "$ACR_PASS"; then
              echo "==> Registry set successfully."
              exit 0
            fi
            echo "==> Attempt $attempt/10: container app busy. Waiting 45s..."
            sleep 45
          done
          echo "==> ERROR: Registry set failed after 10 retries."
          exit 1

      - name: Deploy to Container Apps
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          AZURE_STORAGE_ACCOUNT: ${{ secrets.AZURE_STORAGE_ACCOUNT }}
          AZURE_STORAGE_ACCOUNT_KEY: ${{ secrets.AZURE_STORAGE_ACCOUNT_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          CORS_ALLOW_ORIGINS: ${{ secrets.CORS_ALLOW_ORIGINS }}
          AZURE_STORAGE_CONTAINER_PHOTOS: ${{ secrets.AZURE_STORAGE_CONTAINER_PHOTOS }}
          AZURE_STORAGE_CONTAINER_AUDIO: ${{ secrets.AZURE_STORAGE_CONTAINER_AUDIO }}
          PICOVOICE_ACCESS_KEY: ${{ secrets.PICOVOICE_ACCESS_KEY }}
          VOICE_ID_BACKEND: ${{ vars.VOICE_ID_BACKEND || secrets.VOICE_ID_BACKEND || 'eagle' }}
          AZURE_SPEECH_KEY: ${{ secrets.AZURE_SPEECH_KEY }}
          AZURE_SPEECH_REGION: ${{ secrets.AZURE_SPEECH_REGION }}
          AZURE_SPEECH_ENDPOINT: ${{ secrets.AZURE_SPEECH_ENDPOINT }}
        run: |
          set -e
          echo "==> Deploying to Container App ${{ env.CONTAINER_APP }} (image: ${{ env.IMAGE }})..."
          echo "==> Secrets present (will be sent to Container App):"
          [ -n "$DATABASE_URL" ] && echo "  DATABASE_URL: set" || echo "  DATABASE_URL: (empty)"
          [ -n "$AZURE_STORAGE_ACCOUNT" ] && echo "  AZURE_STORAGE_ACCOUNT: set" || echo "  AZURE_STORAGE_ACCOUNT: (empty)"
          [ -n "$AZURE_STORAGE_ACCOUNT_KEY" ] && echo "  AZURE_STORAGE_ACCOUNT_KEY: set" || echo "  AZURE_STORAGE_ACCOUNT_KEY: (empty)"
          [ -n "$OPENAI_API_KEY" ] && echo "  OPENAI_API_KEY: set" || echo "  OPENAI_API_KEY: (empty)"
          [ -n "$CORS_ALLOW_ORIGINS" ] && echo "  CORS_ALLOW_ORIGINS: set" || echo "  CORS_ALLOW_ORIGINS: (empty)"
          [ -n "$AZURE_STORAGE_CONTAINER_PHOTOS" ] && echo "  AZURE_STORAGE_CONTAINER_PHOTOS: set" || echo "  AZURE_STORAGE_CONTAINER_PHOTOS: (empty, will use default photos)"
          [ -n "$AZURE_STORAGE_CONTAINER_AUDIO" ] && echo "  AZURE_STORAGE_CONTAINER_AUDIO: set" || echo "  AZURE_STORAGE_CONTAINER_AUDIO: (empty, will use default audio)"
          [ -n "$PICOVOICE_ACCESS_KEY" ] && echo "  PICOVOICE_ACCESS_KEY: set" || echo "  PICOVOICE_ACCESS_KEY: (empty, Voice ID disabled when backend=eagle)"
          [ -n "$VOICE_ID_BACKEND" ] && echo "  VOICE_ID_BACKEND: $VOICE_ID_BACKEND" || echo "  VOICE_ID_BACKEND: (empty, default eagle)"
          [ -n "$AZURE_SPEECH_KEY" ] && echo "  AZURE_SPEECH_KEY: set" || echo "  AZURE_SPEECH_KEY: (empty)"
          [ -n "$AZURE_SPEECH_REGION" ] && echo "  AZURE_SPEECH_REGION: set" || echo "  AZURE_SPEECH_REGION: (empty)"
          [ -n "$AZURE_SPEECH_ENDPOINT" ] && echo "  AZURE_SPEECH_ENDPOINT: set" || echo "  AZURE_SPEECH_ENDPOINT: (empty)"
          # Brief wait so any just-finished operation can clear (was 2 min; 30s is enough when app is idle)
          echo "Waiting 30s before container app update..."
          sleep 30
          # Build --set-env-vars from non-empty GitHub Secrets (so Container App gets them at runtime)
          ENV_VARS=()
          [ -n "$DATABASE_URL" ] && ENV_VARS+=( "DATABASE_URL=$DATABASE_URL" )
          [ -n "$AZURE_STORAGE_ACCOUNT" ] && ENV_VARS+=( "AZURE_STORAGE_ACCOUNT=$AZURE_STORAGE_ACCOUNT" )
          [ -n "$AZURE_STORAGE_ACCOUNT_KEY" ] && ENV_VARS+=( "AZURE_STORAGE_ACCOUNT_KEY=$AZURE_STORAGE_ACCOUNT_KEY" )
          [ -n "$OPENAI_API_KEY" ] && ENV_VARS+=( "OPENAI_API_KEY=$OPENAI_API_KEY" )
          [ -n "$CORS_ALLOW_ORIGINS" ] && ENV_VARS+=( "CORS_ALLOW_ORIGINS=$CORS_ALLOW_ORIGINS" )
          [ -n "$AZURE_STORAGE_CONTAINER_PHOTOS" ] && ENV_VARS+=( "AZURE_STORAGE_CONTAINER_PHOTOS=$AZURE_STORAGE_CONTAINER_PHOTOS" )
          [ -n "$AZURE_STORAGE_CONTAINER_AUDIO" ] && ENV_VARS+=( "AZURE_STORAGE_CONTAINER_AUDIO=$AZURE_STORAGE_CONTAINER_AUDIO" )
          [ -n "$PICOVOICE_ACCESS_KEY" ] && ENV_VARS+=( "PICOVOICE_ACCESS_KEY=$PICOVOICE_ACCESS_KEY" )
          [ -n "$VOICE_ID_BACKEND" ] && ENV_VARS+=( "VOICE_ID_BACKEND=$VOICE_ID_BACKEND" )
          [ -n "$AZURE_SPEECH_KEY" ] && ENV_VARS+=( "AZURE_SPEECH_KEY=$AZURE_SPEECH_KEY" )
          [ -n "$AZURE_SPEECH_REGION" ] && ENV_VARS+=( "AZURE_SPEECH_REGION=$AZURE_SPEECH_REGION" )
          [ -n "$AZURE_SPEECH_ENDPOINT" ] && ENV_VARS+=( "AZURE_SPEECH_ENDPOINT=$AZURE_SPEECH_ENDPOINT" )
          ENV_VARS+=( "PORT=80" )
          # Ingress must target port 80 to match app (Azure Container Apps expects 80 unless overridden)
          az containerapp ingress update -g ${{ env.RESOURCE_GROUP }} -n ${{ env.CONTAINER_APP }} --target-port 80 --output none
          UPDATE_ARGS=( --name ${{ env.CONTAINER_APP }} --resource-group ${{ env.RESOURCE_GROUP }} --image ${{ env.IMAGE }} )
          [ ${#ENV_VARS[@]} -gt 0 ] && UPDATE_ARGS+=( --set-env-vars "${ENV_VARS[@]}" )
          echo "==> Running az containerapp update (retries: 12, 45s apart if busy)..."
          for attempt in $(seq 1 12); do
            if az containerapp update "${UPDATE_ARGS[@]}" > /tmp/az-update.log 2>&1; then
              echo "==> Deploy successful. Routing 100% traffic to latest revision..."
              az containerapp ingress traffic set --name ${{ env.CONTAINER_APP }} --resource-group ${{ env.RESOURCE_GROUP }} --revision-weight latest=100 --output none 2>/dev/null || true
              echo "==> Done."
              exit 0
            fi
            echo "==> Attempt $attempt/12: container app update failed or busy. Output:"
            cat /tmp/az-update.log
            echo "==> Waiting 45s before retry..."
            sleep 45
          done
          echo "==> ERROR: Deploy failed after 12 retries. Last az containerapp update output:"
          cat /tmp/az-update.log
          echo "==> If this persists, restart the Container App in Azure Portal and re-run the workflow."
          exit 1
